// ==UserScript==
// @name         YouTube Enhancer
// @namespace    http://tampermonkey.net/
// @version      1.0.12
// @license      Unlicense
// @description  Add dual subtitles to YouTube videos
// @author       Jim Chen
// @homepage     https://jimchen.me
// @match        https://*.youtube.com/*
// @run-at       document-idle
// ==/UserScript==
(function () {
  if (location.href.startsWith("https://www.youtube.com")) {
    document.addEventListener("yt-navigate-finish", () => {
      handleVideoNavigation();
    });
  } else if (location.href.startsWith("https://m.youtube.com")) {
    let lastUrl = window.location.href.split("#")[0];

    function checkUrlChanged() {
      const currentUrl = window.location.href.split("#")[0];
      if (currentUrl !== lastUrl) {
        lastUrl = currentUrl;
        handleVideoNavigation();
      }
    }

    window.addEventListener("popstate", checkUrlChanged);

    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;

    history.pushState = function () {
      const result = originalPushState.apply(this, arguments);
      checkUrlChanged();
      return result;
    };

    history.replaceState = function () {
      const result = originalReplaceState.apply(this, arguments);
      checkUrlChanged();
      return result;
    };

    handleVideoNavigation();
  } else if (location.href.startsWith("https://www.youtube.com/embed")) {
    handleVideoNavigation();
  }

  async function handleVideoNavigation() {
    console.log("FIRED");
    removeSubs();
    const { url: subtitleURL, language } = await extractSubtitleUrl();
    if (subtitleURL == null) return;
    await addOneSubtitle(subtitleURL + "&tlang=en");
    await addOneSubtitle(subtitleURL);
  }

  async function extractSubtitleUrl() {
    function extractYouTubeVideoID() {
      const url = window.location.href;
      const patterns = {
        standard: /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?(?:[^?&]+&)*v=([^&]+)/,
        embed: /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([^?]+)/,
        mobile: /(?:https?:\/\/)?m\.youtube\.com\/watch\?v=([^&]+)/,
      };

      let videoID = null;
      if (patterns.standard.test(url)) {
        videoID = url.match(patterns.standard)[1];
      } else if (patterns.embed.test(url)) {
        videoID = url.match(patterns.embed)[1];
      } else if (patterns.mobile.test(url)) {
        videoID = url.match(patterns.mobile)[1];
      }
      return videoID;
    }
    let videoID = extractYouTubeVideoID();
    if (videoID == null) return;

    const playerData = await new Promise((resolve, reject) => {
      let retries = 0;
      const checkForPlayer = (maxRetries = 5, delay = 1000) => {
        console.log("CHECKED, retries", retries);
        let ytAppData = document.querySelector("#movie_player");
        let captionData = ytAppData?.getPlayerResponse()?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

        if (captionData) {
          const fetchedBaseUrl = captionData[0].baseUrl;
          const fetchedVideoID = fetchedBaseUrl.match(/[?&]v=([^&]+)/)?.[1];
          if (fetchedVideoID !== videoID) {
            if (retries >= maxRetries) {
              reject(new Error("Max retries reached or video ID mismatch"));
            } else {
              retries++;
              setTimeout(checkForPlayer, delay);
            }
          } else {
            resolve(captionData);
          }
        } else {
          if (retries >= maxRetries) {
            reject(new Error("Max retries reached, caption data not found"));
          } else {
            retries++;
            setTimeout(checkForPlayer, delay);
          }
        }
      };
      checkForPlayer();
    });
    if (!playerData) return;
    const hasForeignTrack = playerData.some(({ vssId }) => /(ru|de|fr)/.test(vssId));
    if (hasForeignTrack) {
      const autoGeneratedTrack = playerData.find((track) => ["a.ru", "a.de", "a.fr"].includes(track.vssId));
      const manualTrack = playerData.find((track) => ["ru", "de", "fr"].some((code) => track.vssId.includes(code)));
      const otherTrack = autoGeneratedTrack || manualTrack;
      if (!otherTrack) return;
      return { url: `${otherTrack.baseUrl}&fmt=vtt`, language: otherTrack.vssId };
    }
  }

  async function addOneSubtitle(url, maxRetries = 5, delay = 1000) {
    const video = document.querySelector("video");
    try {
      const response = await fetch(url);
      const subtitleData = (await response.text()).replaceAll("align:start position:0%", "");
      const track = document.createElement("track");
      track.src = "data:text/vtt," + encodeURIComponent(subtitleData);
      await new Promise((resolve) => setTimeout(resolve, delay));
      video.appendChild(track);
      track.track.mode = "showing";
    } catch (error) {
      if (maxRetries > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay));
        return addOneSubtitle(url, maxRetries - 1, delay * maxRetries);
      }
    }
  }

  function removeSubs() {
    const video = document.getElementsByTagName("video")[0];
    if (!video) return;
    const tracks = video.getElementsByTagName("track");
    Array.from(tracks).forEach(function (ele) {
      ele.track.mode = "hidden";
      ele.parentNode.removeChild(ele);
    });
  }
})();
